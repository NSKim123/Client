알고리즘algorithm
 임의의 문제를 해결하기 위한 '절차'적인 방법론

알고리즘 성능 분석 : 임의의 알고리즘의 효율성을 따지는 이론

	시간 복잡도 time complexity : 입력자료 갯수 n개에 대해 해당 알고리즘의 실행빈도수의 추이를 추상화된 수학적 표현으로 한다
	공간 복잡도 space complexity : 입력자료 갯수 n개에 대해 메모리를 얼마나 사용하는지를 추상화된 수학적 표현으로 한다.

	시간 복잡도 구하기 : 임의의 알고리즘의 시간복잡도에 대한 수식을 만들고, 상수무시, 계수 무시, 최고차항을 선택한다. <--왜냐하면 충분히 큰 수를 가정하기 때문이다.

	빅오 표기법 Big-O Notation : 최악의 성능을 대문자 O를 가지고 표기한다.


기초적인 알고리즘

	검색 search : 임의 값을 찾는 문제
		순차검색 sequential search : 앞의 데이터들과 하나하나 비교하여 검색하는 방법  O(n)
		이진트리검색 binary tree search : 이진탐색트리를 이용하여 검색하는 방법  O(log n)
		이분(이분)검색 interpolation search : 정렬된 데이터들에 대해 검색범위를 반씩 줄여가며 검색하는 방법  O(log n)
		해쉬검색 hash search : 해쉬 자료구조를 이용하여 검색하는 방법  O(1)

	정렬 sort : 순서 없이 나열된 자료들을 순서 있게 다시 나열하는 것
		선택 정렬 selection sort
			주요 키워드 : 기준위치, 선택
			동작기전 : 기준위치의 원소와 기준위치 이후의 원소들의 값을 비교하여 최솟값을 찾고 선택한다. (오름차순 정렬)
				  선택한 최솟값을 기준위치의 원소와 교환한다
			
				  기준위치를 하나 증가 시킨다
				  
				  위 과정을 반복한다.

			시간복잡도 : O(n^2) (비교횟수는 항상 n(n-1)/2, 교환횟수는 최악의 경우 n-1)

		삽입 정렬 Insertion sort 	
			주요 키워드 : sorted/unsorted, 삽입
			동작기전 : unsorted의 첫번째 원소를 sorted의 마지막 원소부터 비교하여 앞쪽으로 찾아나가 삽입할 위치를 찾는다.
				  
				  삽입할 위치에 삽입한다.
				  
				  sorted/unsorted의 경계를 증가시킨다

				  위 과정을 반복한다.

			시간복잡도 : O(n^2)  (데이터의 성질이 가장 나쁜 경우(역순정렬) O(n^2) , 데이터의 성질이 가장 좋은 경우 O(n) )
	
		쉘 정렬 shell sort 
			동작기전 : 일정 간격으로 만들어진 부분집합들에 대해 삽입정렬을 수행한다
					
				  간격을 줄인다.

				  위 과정을 반복한다.
				
				  <-- 대체로 정렬된 데이터들에 대해 삽입정렬의 속도가 빨라지는 특성을 이용한 것이다.	

			시간복잡도 : O(n^1.25)

		퀵 정렬 quick sort	